/* * */package posl.editorkit;import java.awt.Font;import java.awt.GraphicsEnvironment;import java.awt.event.InputEvent;import java.awt.event.KeyEvent;import java.util.Arrays;import javax.swing.Action;import javax.swing.JEditorPane;import javax.swing.KeyStroke;import javax.swing.text.DefaultEditorKit;import javax.swing.text.Document;import javax.swing.text.Element;import javax.swing.text.Highlighter;import javax.swing.text.View;import javax.swing.text.ViewFactory;/** * This kit supports a fairly minimal handling of editing java text content. It * supports syntax highlighting and produces the lexical structure of the * document as best it can. */public class PoslEditorKit extends DefaultEditorKit implements ViewFactory {	private View poslView;	private Font DEFAULT_FONT;	private DocumentImpl document;	private Highlighter highlighter;	private String contentType;	/**	 * Install the View on the given EditorPane. This is called by Swing and can	 * be used to do anything you need on the JEditorPane control. Here I set	 * some default Actions.	 * 	 * @param editorPane	 */	@Override	public void install(JEditorPane editorPane) {		super.install(editorPane);		this.highlighter = editorPane.getHighlighter();				editorPane.setFont(DEFAULT_FONT);		editorPane.addCaretListener(new PairCaretListener(getHighlighter(),document));				Action redo = document.redoAction;		Action undo = document.undoAction;				editorPane.getInputMap().put(KeyStroke.getKeyStroke(KeyEvent.VK_Y, InputEvent.CTRL_MASK), "Redo");		editorPane.getActionMap().put("Redo",redo);				editorPane.getInputMap().put(KeyStroke.getKeyStroke(KeyEvent.VK_Z, InputEvent.CTRL_MASK), "Undo");		editorPane.getActionMap().put("Undo",undo);			}	private Highlighter getHighlighter() {		return this.highlighter;	}	/**	 * 	 */	private static final long serialVersionUID = 1L;	public PoslEditorKit(String poslLib) {		super();		this.contentType = poslLib;		GraphicsEnvironment ge = GraphicsEnvironment				.getLocalGraphicsEnvironment();		String[] fonts = ge.getAvailableFontFamilyNames();		Arrays.sort(fonts);		if (Arrays.binarySearch(fonts, "Courier new") >= 0) {			DEFAULT_FONT = new Font("Courier New", Font.PLAIN, 12);		} else if (Arrays.binarySearch(fonts, "Courier") >= 0) {			DEFAULT_FONT = new Font("Courier", Font.PLAIN, 12);		} else if (Arrays.binarySearch(fonts, "Monospaced") >= 0) {			DEFAULT_FONT = new Font("Monospaced", Font.PLAIN, 13);		}		createDefaultDocument();	}	// --- EditorKit methods -------------------------	/**	 * Get the MIME type of the data that this kit represents support for. This	 * kit supports the type <code>text/java</code>.	 */	public String getContentType() {		return contentType;	}	/**	 * Create a copy of the editor kit. This allows an implementation to serve	 * as a prototype for others, so that they can be quickly created.	 */	public Object clone() {		PoslEditorKit kit = new PoslEditorKit(this.contentType);		kit.poslView = poslView;		return kit;	}	/**	 * Creates an uninitialized text storage model that is appropriate for this	 * type of editor.	 * 	 * @return the model	 */	public Document createDefaultDocument() {		if (document == null) {			document = new DocumentImpl(contentType);		}		return (Document) document;	}	/**	 * Fetches a factory that is suitable for producing views of any models that	 * are produced by this kit. The default is to have the UI produce the	 * factory, so this method has no implementation.	 * 	 * @return the view factory	 */	public final ViewFactory getViewFactory() {		return this;	}	@Override	public View create(Element elem) {		return new PoslView(elem);	}}